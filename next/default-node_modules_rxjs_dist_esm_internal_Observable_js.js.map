{"version":3,"file":"default-node_modules_rxjs_dist_esm_internal_Observable_js.js","mappings":"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","sources":["./node_modules/rxjs/src/internal/NotificationFactories.ts","./node_modules/rxjs/src/internal/Observable.ts","./node_modules/rxjs/src/internal/Subscriber.ts","./node_modules/rxjs/src/internal/Subscription.ts","./node_modules/rxjs/src/internal/config.ts","./node_modules/rxjs/src/internal/scheduler/timeoutProvider.ts","./node_modules/rxjs/src/internal/symbol/observable.ts","./node_modules/rxjs/src/internal/util/UnsubscriptionError.ts","./node_modules/rxjs/src/internal/util/arrRemove.ts","./node_modules/rxjs/src/internal/util/createErrorClass.ts","./node_modules/rxjs/src/internal/util/errorContext.ts","./node_modules/rxjs/src/internal/util/identity.ts","./node_modules/rxjs/src/internal/util/isFunction.ts","./node_modules/rxjs/src/internal/util/noop.ts","./node_modules/rxjs/src/internal/util/pipe.ts","./node_modules/rxjs/src/internal/util/reportUnhandledError.ts"],"sourcesContent":["import { CompleteNotification, NextNotification, ErrorNotification } from './types';\n\n/**\n * A completion object optimized for memory use and created to be the\n * same \"shape\" as other notifications in v8.\n * @internal\n */\nexport const COMPLETE_NOTIFICATION = (() => createNotification('C', undefined, undefined) as CompleteNotification)();\n\n/**\n * Internal use only. Creates an optimized error notification that is the same \"shape\"\n * as other notifications.\n * @internal\n */\nexport function errorNotification(error: any): ErrorNotification {\n  return createNotification('E', undefined, error) as any;\n}\n\n/**\n * Internal use only. Creates an optimized next notification that is the same \"shape\"\n * as other notifications.\n * @internal\n */\nexport function nextNotification<T>(value: T) {\n  return createNotification('N', value, undefined) as NextNotification<T>;\n}\n\n/**\n * Ensures that all notifications created internally have the same \"shape\" in v8.\n *\n * TODO: This is only exported to support a crazy legacy test in `groupBy`.\n * @internal\n */\nexport function createNotification(kind: 'N' | 'E' | 'C', value: any, error: any) {\n  return {\n    kind,\n    value,\n    error,\n  };\n}\n","import { Operator } from './Operator';\nimport { SafeSubscriber, Subscriber } from './Subscriber';\nimport { isSubscription, Subscription } from './Subscription';\nimport { TeardownLogic, OperatorFunction, Subscribable, Observer } from './types';\nimport { observable as Symbol_observable } from './symbol/observable';\nimport { pipeFromArray } from './util/pipe';\nimport { config } from './config';\nimport { isFunction } from './util/isFunction';\nimport { errorContext } from './util/errorContext';\n\n/**\n * A representation of any set of values over any amount of time. This is the most basic building block\n * of RxJS.\n *\n * @class Observable<T>\n */\nexport class Observable<T> implements Subscribable<T> {\n  /**\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\n   */\n  source: Observable<any> | undefined;\n\n  /**\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\n   */\n  operator: Operator<any, T> | undefined;\n\n  /**\n   * @constructor\n   * @param {Function} subscribe the function that is called when the Observable is\n   * initially subscribed to. This function is given a Subscriber, to which new values\n   * can be `next`ed, or an `error` method can be called to raise an error, or\n   * `complete` can be called to notify of a successful completion.\n   */\n  constructor(subscribe?: (this: Observable<T>, subscriber: Subscriber<T>) => TeardownLogic) {\n    if (subscribe) {\n      this._subscribe = subscribe;\n    }\n  }\n\n  // HACK: Since TypeScript inherits static properties too, we have to\n  // fight against TypeScript here so Subject can have a different static create signature\n  /**\n   * Creates a new Observable by calling the Observable constructor\n   * @owner Observable\n   * @method create\n   * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor\n   * @return {Observable} a new observable\n   * @nocollapse\n   * @deprecated Use `new Observable()` instead. Will be removed in v8.\n   */\n  static create: (...args: any[]) => any = <T>(subscribe?: (subscriber: Subscriber<T>) => TeardownLogic) => {\n    return new Observable<T>(subscribe);\n  };\n\n  /**\n   * Creates a new Observable, with this Observable instance as the source, and the passed\n   * operator defined as the new observable's operator.\n   * @method lift\n   * @param operator the operator defining the operation to take on the observable\n   * @return a new observable with the Operator applied\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\n   * If you have implemented an operator using `lift`, it is recommended that you create an\n   * operator by simply returning `new Observable()` directly. See \"Creating new operators from\n   * scratch\" section here: https://rxjs.dev/guide/operators\n   */\n  lift<R>(operator?: Operator<T, R>): Observable<R> {\n    const observable = new Observable<R>();\n    observable.source = this;\n    observable.operator = operator;\n    return observable;\n  }\n\n  subscribe(observerOrNext?: Partial<Observer<T>> | ((value: T) => void)): Subscription;\n  /** @deprecated Instead of passing separate callback arguments, use an observer argument. Signatures taking separate callback arguments will be removed in v8. Details: https://rxjs.dev/deprecations/subscribe-arguments */\n  subscribe(next?: ((value: T) => void) | null, error?: ((error: any) => void) | null, complete?: (() => void) | null): Subscription;\n  /**\n   * Invokes an execution of an Observable and registers Observer handlers for notifications it will emit.\n   *\n   * <span class=\"informal\">Use it when you have all these Observables, but still nothing is happening.</span>\n   *\n   * `subscribe` is not a regular operator, but a method that calls Observable's internal `subscribe` function. It\n   * might be for example a function that you passed to Observable's constructor, but most of the time it is\n   * a library implementation, which defines what will be emitted by an Observable, and when it be will emitted. This means\n   * that calling `subscribe` is actually the moment when Observable starts its work, not when it is created, as it is often\n   * the thought.\n   *\n   * Apart from starting the execution of an Observable, this method allows you to listen for values\n   * that an Observable emits, as well as for when it completes or errors. You can achieve this in two\n   * of the following ways.\n   *\n   * The first way is creating an object that implements {@link Observer} interface. It should have methods\n   * defined by that interface, but note that it should be just a regular JavaScript object, which you can create\n   * yourself in any way you want (ES6 class, classic function constructor, object literal etc.). In particular, do\n   * not attempt to use any RxJS implementation details to create Observers - you don't need them. Remember also\n   * that your object does not have to implement all methods. If you find yourself creating a method that doesn't\n   * do anything, you can simply omit it. Note however, if the `error` method is not provided and an error happens,\n   * it will be thrown asynchronously. Errors thrown asynchronously cannot be caught using `try`/`catch`. Instead,\n   * use the {@link onUnhandledError} configuration option or use a runtime handler (like `window.onerror` or\n   * `process.on('error)`) to be notified of unhandled errors. Because of this, it's recommended that you provide\n   * an `error` method to avoid missing thrown errors.\n   *\n   * The second way is to give up on Observer object altogether and simply provide callback functions in place of its methods.\n   * This means you can provide three functions as arguments to `subscribe`, where the first function is equivalent\n   * of a `next` method, the second of an `error` method and the third of a `complete` method. Just as in case of an Observer,\n   * if you do not need to listen for something, you can omit a function by passing `undefined` or `null`,\n   * since `subscribe` recognizes these functions by where they were placed in function call. When it comes\n   * to the `error` function, as with an Observer, if not provided, errors emitted by an Observable will be thrown asynchronously.\n   *\n   * You can, however, subscribe with no parameters at all. This may be the case where you're not interested in terminal events\n   * and you also handled emissions internally by using operators (e.g. using `tap`).\n   *\n   * Whichever style of calling `subscribe` you use, in both cases it returns a Subscription object.\n   * This object allows you to call `unsubscribe` on it, which in turn will stop the work that an Observable does and will clean\n   * up all resources that an Observable used. Note that cancelling a subscription will not call `complete` callback\n   * provided to `subscribe` function, which is reserved for a regular completion signal that comes from an Observable.\n   *\n   * Remember that callbacks provided to `subscribe` are not guaranteed to be called asynchronously.\n   * It is an Observable itself that decides when these functions will be called. For example {@link of}\n   * by default emits all its values synchronously. Always check documentation for how given Observable\n   * will behave when subscribed and if its default behavior can be modified with a `scheduler`.\n   *\n   * #### Examples\n   *\n   * Subscribe with an {@link guide/observer Observer}\n   *\n   * ```ts\n   * import { of } from 'rxjs';\n   *\n   * const sumObserver = {\n   *   sum: 0,\n   *   next(value) {\n   *     console.log('Adding: ' + value);\n   *     this.sum = this.sum + value;\n   *   },\n   *   error() {\n   *     // We actually could just remove this method,\n   *     // since we do not really care about errors right now.\n   *   },\n   *   complete() {\n   *     console.log('Sum equals: ' + this.sum);\n   *   }\n   * };\n   *\n   * of(1, 2, 3) // Synchronously emits 1, 2, 3 and then completes.\n   *   .subscribe(sumObserver);\n   *\n   * // Logs:\n   * // 'Adding: 1'\n   * // 'Adding: 2'\n   * // 'Adding: 3'\n   * // 'Sum equals: 6'\n   * ```\n   *\n   * Subscribe with functions ({@link deprecations/subscribe-arguments deprecated})\n   *\n   * ```ts\n   * import { of } from 'rxjs'\n   *\n   * let sum = 0;\n   *\n   * of(1, 2, 3).subscribe(\n   *   value => {\n   *     console.log('Adding: ' + value);\n   *     sum = sum + value;\n   *   },\n   *   undefined,\n   *   () => console.log('Sum equals: ' + sum)\n   * );\n   *\n   * // Logs:\n   * // 'Adding: 1'\n   * // 'Adding: 2'\n   * // 'Adding: 3'\n   * // 'Sum equals: 6'\n   * ```\n   *\n   * Cancel a subscription\n   *\n   * ```ts\n   * import { interval } from 'rxjs';\n   *\n   * const subscription = interval(1000).subscribe({\n   *   next(num) {\n   *     console.log(num)\n   *   },\n   *   complete() {\n   *     // Will not be called, even when cancelling subscription.\n   *     console.log('completed!');\n   *   }\n   * });\n   *\n   * setTimeout(() => {\n   *   subscription.unsubscribe();\n   *   console.log('unsubscribed!');\n   * }, 2500);\n   *\n   * // Logs:\n   * // 0 after 1s\n   * // 1 after 2s\n   * // 'unsubscribed!' after 2.5s\n   * ```\n   *\n   * @param {Observer|Function} observerOrNext (optional) Either an observer with methods to be called,\n   * or the first of three possible handlers, which is the handler for each value emitted from the subscribed\n   * Observable.\n   * @param {Function} error (optional) A handler for a terminal event resulting from an error. If no error handler is provided,\n   * the error will be thrown asynchronously as unhandled.\n   * @param {Function} complete (optional) A handler for a terminal event resulting from successful completion.\n   * @return {Subscription} a subscription reference to the registered handlers\n   * @method subscribe\n   */\n  subscribe(\n    observerOrNext?: Partial<Observer<T>> | ((value: T) => void) | null,\n    error?: ((error: any) => void) | null,\n    complete?: (() => void) | null\n  ): Subscription {\n    const subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);\n\n    errorContext(() => {\n      const { operator, source } = this;\n      subscriber.add(\n        operator\n          ? // We're dealing with a subscription in the\n            // operator chain to one of our lifted operators.\n            operator.call(subscriber, source)\n          : source\n          ? // If `source` has a value, but `operator` does not, something that\n            // had intimate knowledge of our API, like our `Subject`, must have\n            // set it. We're going to just call `_subscribe` directly.\n            this._subscribe(subscriber)\n          : // In all other cases, we're likely wrapping a user-provided initializer\n            // function, so we need to catch errors and handle them appropriately.\n            this._trySubscribe(subscriber)\n      );\n    });\n\n    return subscriber;\n  }\n\n  /** @internal */\n  protected _trySubscribe(sink: Subscriber<T>): TeardownLogic {\n    try {\n      return this._subscribe(sink);\n    } catch (err) {\n      // We don't need to return anything in this case,\n      // because it's just going to try to `add()` to a subscription\n      // above.\n      sink.error(err);\n    }\n  }\n\n  /**\n   * Used as a NON-CANCELLABLE means of subscribing to an observable, for use with\n   * APIs that expect promises, like `async/await`. You cannot unsubscribe from this.\n   *\n   * **WARNING**: Only use this with observables you *know* will complete. If the source\n   * observable does not complete, you will end up with a promise that is hung up, and\n   * potentially all of the state of an async function hanging out in memory. To avoid\n   * this situation, look into adding something like {@link timeout}, {@link take},\n   * {@link takeWhile}, or {@link takeUntil} amongst others.\n   *\n   * #### Example\n   *\n   * ```ts\n   * import { interval, take } from 'rxjs';\n   *\n   * const source$ = interval(1000).pipe(take(4));\n   *\n   * async function getTotal() {\n   *   let total = 0;\n   *\n   *   await source$.forEach(value => {\n   *     total += value;\n   *     console.log('observable -> ' + value);\n   *   });\n   *\n   *   return total;\n   * }\n   *\n   * getTotal().then(\n   *   total => console.log('Total: ' + total)\n   * );\n   *\n   * // Expected:\n   * // 'observable -> 0'\n   * // 'observable -> 1'\n   * // 'observable -> 2'\n   * // 'observable -> 3'\n   * // 'Total: 6'\n   * ```\n   *\n   * @param next a handler for each value emitted by the observable\n   * @return a promise that either resolves on observable completion or\n   *  rejects with the handled error\n   */\n  forEach(next: (value: T) => void): Promise<void>;\n\n  /**\n   * @param next a handler for each value emitted by the observable\n   * @param promiseCtor a constructor function used to instantiate the Promise\n   * @return a promise that either resolves on observable completion or\n   *  rejects with the handled error\n   * @deprecated Passing a Promise constructor will no longer be available\n   * in upcoming versions of RxJS. This is because it adds weight to the library, for very\n   * little benefit. If you need this functionality, it is recommended that you either\n   * polyfill Promise, or you create an adapter to convert the returned native promise\n   * to whatever promise implementation you wanted. Will be removed in v8.\n   */\n  forEach(next: (value: T) => void, promiseCtor: PromiseConstructorLike): Promise<void>;\n\n  forEach(next: (value: T) => void, promiseCtor?: PromiseConstructorLike): Promise<void> {\n    promiseCtor = getPromiseCtor(promiseCtor);\n\n    return new promiseCtor<void>((resolve, reject) => {\n      const subscriber = new SafeSubscriber<T>({\n        next: (value) => {\n          try {\n            next(value);\n          } catch (err) {\n            reject(err);\n            subscriber.unsubscribe();\n          }\n        },\n        error: reject,\n        complete: resolve,\n      });\n      this.subscribe(subscriber);\n    }) as Promise<void>;\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<any>): TeardownLogic {\n    return this.source?.subscribe(subscriber);\n  }\n\n  /**\n   * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable\n   * @method Symbol.observable\n   * @return {Observable} this instance of the observable\n   */\n  [Symbol_observable]() {\n    return this;\n  }\n\n  /* tslint:disable:max-line-length */\n  pipe(): Observable<T>;\n  pipe<A>(op1: OperatorFunction<T, A>): Observable<A>;\n  pipe<A, B>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>): Observable<B>;\n  pipe<A, B, C>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>): Observable<C>;\n  pipe<A, B, C, D>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>\n  ): Observable<D>;\n  pipe<A, B, C, D, E>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>\n  ): Observable<E>;\n  pipe<A, B, C, D, E, F>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>,\n    op6: OperatorFunction<E, F>\n  ): Observable<F>;\n  pipe<A, B, C, D, E, F, G>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>,\n    op6: OperatorFunction<E, F>,\n    op7: OperatorFunction<F, G>\n  ): Observable<G>;\n  pipe<A, B, C, D, E, F, G, H>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>,\n    op6: OperatorFunction<E, F>,\n    op7: OperatorFunction<F, G>,\n    op8: OperatorFunction<G, H>\n  ): Observable<H>;\n  pipe<A, B, C, D, E, F, G, H, I>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>,\n    op6: OperatorFunction<E, F>,\n    op7: OperatorFunction<F, G>,\n    op8: OperatorFunction<G, H>,\n    op9: OperatorFunction<H, I>\n  ): Observable<I>;\n  pipe<A, B, C, D, E, F, G, H, I>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>,\n    op6: OperatorFunction<E, F>,\n    op7: OperatorFunction<F, G>,\n    op8: OperatorFunction<G, H>,\n    op9: OperatorFunction<H, I>,\n    ...operations: OperatorFunction<any, any>[]\n  ): Observable<unknown>;\n  /* tslint:enable:max-line-length */\n\n  /**\n   * Used to stitch together functional operators into a chain.\n   * @method pipe\n   * @return {Observable} the Observable result of all of the operators having\n   * been called in the order they were passed in.\n   *\n   * ## Example\n   *\n   * ```ts\n   * import { interval, filter, map, scan } from 'rxjs';\n   *\n   * interval(1000)\n   *   .pipe(\n   *     filter(x => x % 2 === 0),\n   *     map(x => x + x),\n   *     scan((acc, x) => acc + x)\n   *   )\n   *   .subscribe(x => console.log(x));\n   * ```\n   */\n  pipe(...operations: OperatorFunction<any, any>[]): Observable<any> {\n    return pipeFromArray(operations)(this);\n  }\n\n  /* tslint:disable:max-line-length */\n  /** @deprecated Replaced with {@link firstValueFrom} and {@link lastValueFrom}. Will be removed in v8. Details: https://rxjs.dev/deprecations/to-promise */\n  toPromise(): Promise<T | undefined>;\n  /** @deprecated Replaced with {@link firstValueFrom} and {@link lastValueFrom}. Will be removed in v8. Details: https://rxjs.dev/deprecations/to-promise */\n  toPromise(PromiseCtor: typeof Promise): Promise<T | undefined>;\n  /** @deprecated Replaced with {@link firstValueFrom} and {@link lastValueFrom}. Will be removed in v8. Details: https://rxjs.dev/deprecations/to-promise */\n  toPromise(PromiseCtor: PromiseConstructorLike): Promise<T | undefined>;\n  /* tslint:enable:max-line-length */\n\n  /**\n   * Subscribe to this Observable and get a Promise resolving on\n   * `complete` with the last emission (if any).\n   *\n   * **WARNING**: Only use this with observables you *know* will complete. If the source\n   * observable does not complete, you will end up with a promise that is hung up, and\n   * potentially all of the state of an async function hanging out in memory. To avoid\n   * this situation, look into adding something like {@link timeout}, {@link take},\n   * {@link takeWhile}, or {@link takeUntil} amongst others.\n   *\n   * @method toPromise\n   * @param [promiseCtor] a constructor function used to instantiate\n   * the Promise\n   * @return A Promise that resolves with the last value emit, or\n   * rejects on an error. If there were no emissions, Promise\n   * resolves with undefined.\n   * @deprecated Replaced with {@link firstValueFrom} and {@link lastValueFrom}. Will be removed in v8. Details: https://rxjs.dev/deprecations/to-promise\n   */\n  toPromise(promiseCtor?: PromiseConstructorLike): Promise<T | undefined> {\n    promiseCtor = getPromiseCtor(promiseCtor);\n\n    return new promiseCtor((resolve, reject) => {\n      let value: T | undefined;\n      this.subscribe(\n        (x: T) => (value = x),\n        (err: any) => reject(err),\n        () => resolve(value)\n      );\n    }) as Promise<T | undefined>;\n  }\n}\n\n/**\n * Decides between a passed promise constructor from consuming code,\n * A default configured promise constructor, and the native promise\n * constructor and returns it. If nothing can be found, it will throw\n * an error.\n * @param promiseCtor The optional promise constructor to passed by consuming code\n */\nfunction getPromiseCtor(promiseCtor: PromiseConstructorLike | undefined) {\n  return promiseCtor ?? config.Promise ?? Promise;\n}\n\nfunction isObserver<T>(value: any): value is Observer<T> {\n  return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);\n}\n\nfunction isSubscriber<T>(value: any): value is Subscriber<T> {\n  return (value && value instanceof Subscriber) || (isObserver(value) && isSubscription(value));\n}\n","import { isFunction } from './util/isFunction';\nimport { Observer, ObservableNotification } from './types';\nimport { isSubscription, Subscription } from './Subscription';\nimport { config } from './config';\nimport { reportUnhandledError } from './util/reportUnhandledError';\nimport { noop } from './util/noop';\nimport { nextNotification, errorNotification, COMPLETE_NOTIFICATION } from './NotificationFactories';\nimport { timeoutProvider } from './scheduler/timeoutProvider';\nimport { captureError } from './util/errorContext';\n\n/**\n * Implements the {@link Observer} interface and extends the\n * {@link Subscription} class. While the {@link Observer} is the public API for\n * consuming the values of an {@link Observable}, all Observers get converted to\n * a Subscriber, in order to provide Subscription-like capabilities such as\n * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for\n * implementing operators, but it is rarely used as a public API.\n *\n * @class Subscriber<T>\n */\nexport class Subscriber<T> extends Subscription implements Observer<T> {\n  /**\n   * A static factory for a Subscriber, given a (potentially partial) definition\n   * of an Observer.\n   * @param next The `next` callback of an Observer.\n   * @param error The `error` callback of an\n   * Observer.\n   * @param complete The `complete` callback of an\n   * Observer.\n   * @return A Subscriber wrapping the (partially defined)\n   * Observer represented by the given arguments.\n   * @nocollapse\n   * @deprecated Do not use. Will be removed in v8. There is no replacement for this\n   * method, and there is no reason to be creating instances of `Subscriber` directly.\n   * If you have a specific use case, please file an issue.\n   */\n  static create<T>(next?: (x?: T) => void, error?: (e?: any) => void, complete?: () => void): Subscriber<T> {\n    return new SafeSubscriber(next, error, complete);\n  }\n\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  protected isStopped: boolean = false;\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  protected destination: Subscriber<any> | Observer<any>; // this `any` is the escape hatch to erase extra type param (e.g. R)\n\n  /**\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\n   * There is no reason to directly create an instance of Subscriber. This type is exported for typings reasons.\n   */\n  constructor(destination?: Subscriber<any> | Observer<any>) {\n    super();\n    if (destination) {\n      this.destination = destination;\n      // Automatically chain subscriptions together here.\n      // if destination is a Subscription, then it is a Subscriber.\n      if (isSubscription(destination)) {\n        destination.add(this);\n      }\n    } else {\n      this.destination = EMPTY_OBSERVER;\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `next` from\n   * the Observable, with a value. The Observable may call this method 0 or more\n   * times.\n   * @param {T} [value] The `next` value.\n   * @return {void}\n   */\n  next(value?: T): void {\n    if (this.isStopped) {\n      handleStoppedNotification(nextNotification(value), this);\n    } else {\n      this._next(value!);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `error` from\n   * the Observable, with an attached `Error`. Notifies the Observer that\n   * the Observable has experienced an error condition.\n   * @param {any} [err] The `error` exception.\n   * @return {void}\n   */\n  error(err?: any): void {\n    if (this.isStopped) {\n      handleStoppedNotification(errorNotification(err), this);\n    } else {\n      this.isStopped = true;\n      this._error(err);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive a valueless notification of type\n   * `complete` from the Observable. Notifies the Observer that the Observable\n   * has finished sending push-based notifications.\n   * @return {void}\n   */\n  complete(): void {\n    if (this.isStopped) {\n      handleStoppedNotification(COMPLETE_NOTIFICATION, this);\n    } else {\n      this.isStopped = true;\n      this._complete();\n    }\n  }\n\n  unsubscribe(): void {\n    if (!this.closed) {\n      this.isStopped = true;\n      super.unsubscribe();\n      this.destination = null!;\n    }\n  }\n\n  protected _next(value: T): void {\n    this.destination.next(value);\n  }\n\n  protected _error(err: any): void {\n    try {\n      this.destination.error(err);\n    } finally {\n      this.unsubscribe();\n    }\n  }\n\n  protected _complete(): void {\n    try {\n      this.destination.complete();\n    } finally {\n      this.unsubscribe();\n    }\n  }\n}\n\n/**\n * This bind is captured here because we want to be able to have\n * compatibility with monoid libraries that tend to use a method named\n * `bind`. In particular, a library called Monio requires this.\n */\nconst _bind = Function.prototype.bind;\n\nfunction bind<Fn extends (...args: any[]) => any>(fn: Fn, thisArg: any): Fn {\n  return _bind.call(fn, thisArg);\n}\n\n/**\n * Internal optimization only, DO NOT EXPOSE.\n * @internal\n */\nclass ConsumerObserver<T> implements Observer<T> {\n  constructor(private partialObserver: Partial<Observer<T>>) {}\n\n  next(value: T): void {\n    const { partialObserver } = this;\n    if (partialObserver.next) {\n      try {\n        partialObserver.next(value);\n      } catch (error) {\n        handleUnhandledError(error);\n      }\n    }\n  }\n\n  error(err: any): void {\n    const { partialObserver } = this;\n    if (partialObserver.error) {\n      try {\n        partialObserver.error(err);\n      } catch (error) {\n        handleUnhandledError(error);\n      }\n    } else {\n      handleUnhandledError(err);\n    }\n  }\n\n  complete(): void {\n    const { partialObserver } = this;\n    if (partialObserver.complete) {\n      try {\n        partialObserver.complete();\n      } catch (error) {\n        handleUnhandledError(error);\n      }\n    }\n  }\n}\n\nexport class SafeSubscriber<T> extends Subscriber<T> {\n  constructor(\n    observerOrNext?: Partial<Observer<T>> | ((value: T) => void) | null,\n    error?: ((e?: any) => void) | null,\n    complete?: (() => void) | null\n  ) {\n    super();\n\n    let partialObserver: Partial<Observer<T>>;\n    if (isFunction(observerOrNext) || !observerOrNext) {\n      // The first argument is a function, not an observer. The next\n      // two arguments *could* be observers, or they could be empty.\n      partialObserver = {\n        next: (observerOrNext ?? undefined) as (((value: T) => void) | undefined),\n        error: error ?? undefined,\n        complete: complete ?? undefined,\n      };\n    } else {\n      // The first argument is a partial observer.\n      let context: any;\n      if (this && config.useDeprecatedNextContext) {\n        // This is a deprecated path that made `this.unsubscribe()` available in\n        // next handler functions passed to subscribe. This only exists behind a flag\n        // now, as it is *very* slow.\n        context = Object.create(observerOrNext);\n        context.unsubscribe = () => this.unsubscribe();\n        partialObserver = {\n          next: observerOrNext.next && bind(observerOrNext.next, context),\n          error: observerOrNext.error && bind(observerOrNext.error, context),\n          complete: observerOrNext.complete && bind(observerOrNext.complete, context),\n        };\n      } else {\n        // The \"normal\" path. Just use the partial observer directly.\n        partialObserver = observerOrNext;\n      }\n    }\n\n    // Wrap the partial observer to ensure it's a full observer, and\n    // make sure proper error handling is accounted for.\n    this.destination = new ConsumerObserver(partialObserver);\n  }\n}\n\nfunction handleUnhandledError(error: any) {\n  if (config.useDeprecatedSynchronousErrorHandling) {\n    captureError(error);\n  } else {\n    // Ideal path, we report this as an unhandled error,\n    // which is thrown on a new call stack.\n    reportUnhandledError(error);\n  }\n}\n\n/**\n * An error handler used when no error handler was supplied\n * to the SafeSubscriber -- meaning no error handler was supplied\n * do the `subscribe` call on our observable.\n * @param err The error to handle\n */\nfunction defaultErrorHandler(err: any) {\n  throw err;\n}\n\n/**\n * A handler for notifications that cannot be sent to a stopped subscriber.\n * @param notification The notification being sent\n * @param subscriber The stopped subscriber\n */\nfunction handleStoppedNotification(notification: ObservableNotification<any>, subscriber: Subscriber<any>) {\n  const { onStoppedNotification } = config;\n  onStoppedNotification && timeoutProvider.setTimeout(() => onStoppedNotification(notification, subscriber));\n}\n\n/**\n * The observer used as a stub for subscriptions where the user did not\n * pass any arguments to `subscribe`. Comes with the default error handling\n * behavior.\n */\nexport const EMPTY_OBSERVER: Readonly<Observer<any>> & { closed: true } = {\n  closed: true,\n  next: noop,\n  error: defaultErrorHandler,\n  complete: noop,\n};\n","import { isFunction } from './util/isFunction';\nimport { UnsubscriptionError } from './util/UnsubscriptionError';\nimport { SubscriptionLike, TeardownLogic, Unsubscribable } from './types';\nimport { arrRemove } from './util/arrRemove';\n\n/**\n * Represents a disposable resource, such as the execution of an Observable. A\n * Subscription has one important method, `unsubscribe`, that takes no argument\n * and just disposes the resource held by the subscription.\n *\n * Additionally, subscriptions may be grouped together through the `add()`\n * method, which will attach a child Subscription to the current Subscription.\n * When a Subscription is unsubscribed, all its children (and its grandchildren)\n * will be unsubscribed as well.\n *\n * @class Subscription\n */\nexport class Subscription implements SubscriptionLike {\n  /** @nocollapse */\n  public static EMPTY = (() => {\n    const empty = new Subscription();\n    empty.closed = true;\n    return empty;\n  })();\n\n  /**\n   * A flag to indicate whether this Subscription has already been unsubscribed.\n   */\n  public closed = false;\n\n  private _parentage: Subscription[] | Subscription | null = null;\n\n  /**\n   * The list of registered finalizers to execute upon unsubscription. Adding and removing from this\n   * list occurs in the {@link #add} and {@link #remove} methods.\n   */\n  private _finalizers: Exclude<TeardownLogic, void>[] | null = null;\n\n  /**\n   * @param initialTeardown A function executed first as part of the finalization\n   * process that is kicked off when {@link #unsubscribe} is called.\n   */\n  constructor(private initialTeardown?: () => void) {}\n\n  /**\n   * Disposes the resources held by the subscription. May, for instance, cancel\n   * an ongoing Observable execution or cancel any other type of work that\n   * started when the Subscription was created.\n   * @return {void}\n   */\n  unsubscribe(): void {\n    let errors: any[] | undefined;\n\n    if (!this.closed) {\n      this.closed = true;\n\n      // Remove this from it's parents.\n      const { _parentage } = this;\n      if (_parentage) {\n        this._parentage = null;\n        if (Array.isArray(_parentage)) {\n          for (const parent of _parentage) {\n            parent.remove(this);\n          }\n        } else {\n          _parentage.remove(this);\n        }\n      }\n\n      const { initialTeardown: initialFinalizer } = this;\n      if (isFunction(initialFinalizer)) {\n        try {\n          initialFinalizer();\n        } catch (e) {\n          errors = e instanceof UnsubscriptionError ? e.errors : [e];\n        }\n      }\n\n      const { _finalizers } = this;\n      if (_finalizers) {\n        this._finalizers = null;\n        for (const finalizer of _finalizers) {\n          try {\n            execFinalizer(finalizer);\n          } catch (err) {\n            errors = errors ?? [];\n            if (err instanceof UnsubscriptionError) {\n              errors = [...errors, ...err.errors];\n            } else {\n              errors.push(err);\n            }\n          }\n        }\n      }\n\n      if (errors) {\n        throw new UnsubscriptionError(errors);\n      }\n    }\n  }\n\n  /**\n   * Adds a finalizer to this subscription, so that finalization will be unsubscribed/called\n   * when this subscription is unsubscribed. If this subscription is already {@link #closed},\n   * because it has already been unsubscribed, then whatever finalizer is passed to it\n   * will automatically be executed (unless the finalizer itself is also a closed subscription).\n   *\n   * Closed Subscriptions cannot be added as finalizers to any subscription. Adding a closed\n   * subscription to a any subscription will result in no operation. (A noop).\n   *\n   * Adding a subscription to itself, or adding `null` or `undefined` will not perform any\n   * operation at all. (A noop).\n   *\n   * `Subscription` instances that are added to this instance will automatically remove themselves\n   * if they are unsubscribed. Functions and {@link Unsubscribable} objects that you wish to remove\n   * will need to be removed manually with {@link #remove}\n   *\n   * @param teardown The finalization logic to add to this subscription.\n   */\n  add(teardown: TeardownLogic): void {\n    // Only add the finalizer if it's not undefined\n    // and don't add a subscription to itself.\n    if (teardown && teardown !== this) {\n      if (this.closed) {\n        // If this subscription is already closed,\n        // execute whatever finalizer is handed to it automatically.\n        execFinalizer(teardown);\n      } else {\n        if (teardown instanceof Subscription) {\n          // We don't add closed subscriptions, and we don't add the same subscription\n          // twice. Subscription unsubscribe is idempotent.\n          if (teardown.closed || teardown._hasParent(this)) {\n            return;\n          }\n          teardown._addParent(this);\n        }\n        (this._finalizers = this._finalizers ?? []).push(teardown);\n      }\n    }\n  }\n\n  /**\n   * Checks to see if a this subscription already has a particular parent.\n   * This will signal that this subscription has already been added to the parent in question.\n   * @param parent the parent to check for\n   */\n  private _hasParent(parent: Subscription) {\n    const { _parentage } = this;\n    return _parentage === parent || (Array.isArray(_parentage) && _parentage.includes(parent));\n  }\n\n  /**\n   * Adds a parent to this subscription so it can be removed from the parent if it\n   * unsubscribes on it's own.\n   *\n   * NOTE: THIS ASSUMES THAT {@link _hasParent} HAS ALREADY BEEN CHECKED.\n   * @param parent The parent subscription to add\n   */\n  private _addParent(parent: Subscription) {\n    const { _parentage } = this;\n    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;\n  }\n\n  /**\n   * Called on a child when it is removed via {@link #remove}.\n   * @param parent The parent to remove\n   */\n  private _removeParent(parent: Subscription) {\n    const { _parentage } = this;\n    if (_parentage === parent) {\n      this._parentage = null;\n    } else if (Array.isArray(_parentage)) {\n      arrRemove(_parentage, parent);\n    }\n  }\n\n  /**\n   * Removes a finalizer from this subscription that was previously added with the {@link #add} method.\n   *\n   * Note that `Subscription` instances, when unsubscribed, will automatically remove themselves\n   * from every other `Subscription` they have been added to. This means that using the `remove` method\n   * is not a common thing and should be used thoughtfully.\n   *\n   * If you add the same finalizer instance of a function or an unsubscribable object to a `Subscription` instance\n   * more than once, you will need to call `remove` the same number of times to remove all instances.\n   *\n   * All finalizer instances are removed to free up memory upon unsubscription.\n   *\n   * @param teardown The finalizer to remove from this subscription\n   */\n  remove(teardown: Exclude<TeardownLogic, void>): void {\n    const { _finalizers } = this;\n    _finalizers && arrRemove(_finalizers, teardown);\n\n    if (teardown instanceof Subscription) {\n      teardown._removeParent(this);\n    }\n  }\n}\n\nexport const EMPTY_SUBSCRIPTION = Subscription.EMPTY;\n\nexport function isSubscription(value: any): value is Subscription {\n  return (\n    value instanceof Subscription ||\n    (value && 'closed' in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe))\n  );\n}\n\nfunction execFinalizer(finalizer: Unsubscribable | (() => void)) {\n  if (isFunction(finalizer)) {\n    finalizer();\n  } else {\n    finalizer.unsubscribe();\n  }\n}\n","import { Subscriber } from './Subscriber';\nimport { ObservableNotification } from './types';\n\n/**\n * The {@link GlobalConfig} object for RxJS. It is used to configure things\n * like how to react on unhandled errors.\n */\nexport const config: GlobalConfig = {\n  onUnhandledError: null,\n  onStoppedNotification: null,\n  Promise: undefined,\n  useDeprecatedSynchronousErrorHandling: false,\n  useDeprecatedNextContext: false,\n};\n\n/**\n * The global configuration object for RxJS, used to configure things\n * like how to react on unhandled errors. Accessible via {@link config}\n * object.\n */\nexport interface GlobalConfig {\n  /**\n   * A registration point for unhandled errors from RxJS. These are errors that\n   * cannot were not handled by consuming code in the usual subscription path. For\n   * example, if you have this configured, and you subscribe to an observable without\n   * providing an error handler, errors from that subscription will end up here. This\n   * will _always_ be called asynchronously on another job in the runtime. This is because\n   * we do not want errors thrown in this user-configured handler to interfere with the\n   * behavior of the library.\n   */\n  onUnhandledError: ((err: any) => void) | null;\n\n  /**\n   * A registration point for notifications that cannot be sent to subscribers because they\n   * have completed, errored or have been explicitly unsubscribed. By default, next, complete\n   * and error notifications sent to stopped subscribers are noops. However, sometimes callers\n   * might want a different behavior. For example, with sources that attempt to report errors\n   * to stopped subscribers, a caller can configure RxJS to throw an unhandled error instead.\n   * This will _always_ be called asynchronously on another job in the runtime. This is because\n   * we do not want errors thrown in this user-configured handler to interfere with the\n   * behavior of the library.\n   */\n  onStoppedNotification: ((notification: ObservableNotification<any>, subscriber: Subscriber<any>) => void) | null;\n\n  /**\n   * The promise constructor used by default for {@link Observable#toPromise toPromise} and {@link Observable#forEach forEach}\n   * methods.\n   *\n   * @deprecated As of version 8, RxJS will no longer support this sort of injection of a\n   * Promise constructor. If you need a Promise implementation other than native promises,\n   * please polyfill/patch Promise as you see appropriate. Will be removed in v8.\n   */\n  Promise?: PromiseConstructorLike;\n\n  /**\n   * If true, turns on synchronous error rethrowing, which is a deprecated behavior\n   * in v6 and higher. This behavior enables bad patterns like wrapping a subscribe\n   * call in a try/catch block. It also enables producer interference, a nasty bug\n   * where a multicast can be broken for all observers by a downstream consumer with\n   * an unhandled error. DO NOT USE THIS FLAG UNLESS IT'S NEEDED TO BUY TIME\n   * FOR MIGRATION REASONS.\n   *\n   * @deprecated As of version 8, RxJS will no longer support synchronous throwing\n   * of unhandled errors. All errors will be thrown on a separate call stack to prevent bad\n   * behaviors described above. Will be removed in v8.\n   */\n  useDeprecatedSynchronousErrorHandling: boolean;\n\n  /**\n   * If true, enables an as-of-yet undocumented feature from v5: The ability to access\n   * `unsubscribe()` via `this` context in `next` functions created in observers passed\n   * to `subscribe`.\n   *\n   * This is being removed because the performance was severely problematic, and it could also cause\n   * issues when types other than POJOs are passed to subscribe as subscribers, as they will likely have\n   * their `this` context overwritten.\n   *\n   * @deprecated As of version 8, RxJS will no longer support altering the\n   * context of next functions provided as part of an observer to Subscribe. Instead,\n   * you will have access to a subscription or a signal or token that will allow you to do things like\n   * unsubscribe and test closed status. Will be removed in v8.\n   */\n  useDeprecatedNextContext: boolean;\n}\n","import type { TimerHandle } from './timerHandle';\ntype SetTimeoutFunction = (handler: () => void, timeout?: number, ...args: any[]) => TimerHandle;\ntype ClearTimeoutFunction = (handle: TimerHandle) => void;\n\ninterface TimeoutProvider {\n  setTimeout: SetTimeoutFunction;\n  clearTimeout: ClearTimeoutFunction;\n  delegate:\n    | {\n        setTimeout: SetTimeoutFunction;\n        clearTimeout: ClearTimeoutFunction;\n      }\n    | undefined;\n}\n\nexport const timeoutProvider: TimeoutProvider = {\n  // When accessing the delegate, use the variable rather than `this` so that\n  // the functions can be called without being bound to the provider.\n  setTimeout(handler: () => void, timeout?: number, ...args) {\n    const { delegate } = timeoutProvider;\n    if (delegate?.setTimeout) {\n      return delegate.setTimeout(handler, timeout, ...args);\n    }\n    return setTimeout(handler, timeout, ...args);\n  },\n  clearTimeout(handle) {\n    const { delegate } = timeoutProvider;\n    return (delegate?.clearTimeout || clearTimeout)(handle as any);\n  },\n  delegate: undefined,\n};\n","/**\n * Symbol.observable or a string \"@@observable\". Used for interop\n *\n * @deprecated We will no longer be exporting this symbol in upcoming versions of RxJS.\n * Instead polyfill and use Symbol.observable directly *or* use https://www.npmjs.com/package/symbol-observable\n */\nexport const observable: string | symbol = (() => (typeof Symbol === 'function' && Symbol.observable) || '@@observable')();\n","import { createErrorClass } from './createErrorClass';\n\nexport interface UnsubscriptionError extends Error {\n  readonly errors: any[];\n}\n\nexport interface UnsubscriptionErrorCtor {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  new (errors: any[]): UnsubscriptionError;\n}\n\n/**\n * An error thrown when one or more errors have occurred during the\n * `unsubscribe` of a {@link Subscription}.\n */\nexport const UnsubscriptionError: UnsubscriptionErrorCtor = createErrorClass(\n  (_super) =>\n    function UnsubscriptionErrorImpl(this: any, errors: (Error | string)[]) {\n      _super(this);\n      this.message = errors\n        ? `${errors.length} errors occurred during unsubscription:\n${errors.map((err, i) => `${i + 1}) ${err.toString()}`).join('\\n  ')}`\n        : '';\n      this.name = 'UnsubscriptionError';\n      this.errors = errors;\n    }\n);\n","/**\n * Removes an item from an array, mutating it.\n * @param arr The array to remove the item from\n * @param item The item to remove\n */\nexport function arrRemove<T>(arr: T[] | undefined | null, item: T) {\n  if (arr) {\n    const index = arr.indexOf(item);\n    0 <= index && arr.splice(index, 1);\n  }\n}\n","/**\n * Used to create Error subclasses until the community moves away from ES5.\n *\n * This is because compiling from TypeScript down to ES5 has issues with subclassing Errors\n * as well as other built-in types: https://github.com/Microsoft/TypeScript/issues/12123\n *\n * @param createImpl A factory function to create the actual constructor implementation. The returned\n * function should be a named function that calls `_super` internally.\n */\nexport function createErrorClass<T>(createImpl: (_super: any) => any): T {\n  const _super = (instance: any) => {\n    Error.call(instance);\n    instance.stack = new Error().stack;\n  };\n\n  const ctorFunc = createImpl(_super);\n  ctorFunc.prototype = Object.create(Error.prototype);\n  ctorFunc.prototype.constructor = ctorFunc;\n  return ctorFunc;\n}\n","import { config } from '../config';\n\nlet context: { errorThrown: boolean; error: any } | null = null;\n\n/**\n * Handles dealing with errors for super-gross mode. Creates a context, in which\n * any synchronously thrown errors will be passed to {@link captureError}. Which\n * will record the error such that it will be rethrown after the call back is complete.\n * TODO: Remove in v8\n * @param cb An immediately executed function.\n */\nexport function errorContext(cb: () => void) {\n  if (config.useDeprecatedSynchronousErrorHandling) {\n    const isRoot = !context;\n    if (isRoot) {\n      context = { errorThrown: false, error: null };\n    }\n    cb();\n    if (isRoot) {\n      const { errorThrown, error } = context!;\n      context = null;\n      if (errorThrown) {\n        throw error;\n      }\n    }\n  } else {\n    // This is the general non-deprecated path for everyone that\n    // isn't crazy enough to use super-gross mode (useDeprecatedSynchronousErrorHandling)\n    cb();\n  }\n}\n\n/**\n * Captures errors only in super-gross mode.\n * @param err the error to capture\n */\nexport function captureError(err: any) {\n  if (config.useDeprecatedSynchronousErrorHandling && context) {\n    context.errorThrown = true;\n    context.error = err;\n  }\n}\n","/**\n * This function takes one parameter and just returns it. Simply put,\n * this is like `<T>(x: T): T => x`.\n *\n * ## Examples\n *\n * This is useful in some cases when using things like `mergeMap`\n *\n * ```ts\n * import { interval, take, map, range, mergeMap, identity } from 'rxjs';\n *\n * const source$ = interval(1000).pipe(take(5));\n *\n * const result$ = source$.pipe(\n *   map(i => range(i)),\n *   mergeMap(identity) // same as mergeMap(x => x)\n * );\n *\n * result$.subscribe({\n *   next: console.log\n * });\n * ```\n *\n * Or when you want to selectively apply an operator\n *\n * ```ts\n * import { interval, take, identity } from 'rxjs';\n *\n * const shouldLimit = () => Math.random() < 0.5;\n *\n * const source$ = interval(1000);\n *\n * const result$ = source$.pipe(shouldLimit() ? take(5) : identity);\n *\n * result$.subscribe({\n *   next: console.log\n * });\n * ```\n *\n * @param x Any value that is returned by this function\n * @returns The value passed as the first parameter to this function\n */\nexport function identity<T>(x: T): T {\n  return x;\n}\n","/**\n * Returns true if the object is a function.\n * @param value The value to check\n */\nexport function isFunction(value: any): value is (...args: any[]) => any {\n  return typeof value === 'function';\n}\n","/* tslint:disable:no-empty */\nexport function noop() { }\n","import { identity } from './identity';\nimport { UnaryFunction } from '../types';\n\nexport function pipe(): typeof identity;\nexport function pipe<T, A>(fn1: UnaryFunction<T, A>): UnaryFunction<T, A>;\nexport function pipe<T, A, B>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>): UnaryFunction<T, B>;\nexport function pipe<T, A, B, C>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>): UnaryFunction<T, C>;\nexport function pipe<T, A, B, C, D>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>\n): UnaryFunction<T, D>;\nexport function pipe<T, A, B, C, D, E>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>\n): UnaryFunction<T, E>;\nexport function pipe<T, A, B, C, D, E, F>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>,\n  fn6: UnaryFunction<E, F>\n): UnaryFunction<T, F>;\nexport function pipe<T, A, B, C, D, E, F, G>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>,\n  fn6: UnaryFunction<E, F>,\n  fn7: UnaryFunction<F, G>\n): UnaryFunction<T, G>;\nexport function pipe<T, A, B, C, D, E, F, G, H>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>,\n  fn6: UnaryFunction<E, F>,\n  fn7: UnaryFunction<F, G>,\n  fn8: UnaryFunction<G, H>\n): UnaryFunction<T, H>;\nexport function pipe<T, A, B, C, D, E, F, G, H, I>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>,\n  fn6: UnaryFunction<E, F>,\n  fn7: UnaryFunction<F, G>,\n  fn8: UnaryFunction<G, H>,\n  fn9: UnaryFunction<H, I>\n): UnaryFunction<T, I>;\nexport function pipe<T, A, B, C, D, E, F, G, H, I>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>,\n  fn6: UnaryFunction<E, F>,\n  fn7: UnaryFunction<F, G>,\n  fn8: UnaryFunction<G, H>,\n  fn9: UnaryFunction<H, I>,\n  ...fns: UnaryFunction<any, any>[]\n): UnaryFunction<T, unknown>;\n\n/**\n * pipe() can be called on one or more functions, each of which can take one argument (\"UnaryFunction\")\n * and uses it to return a value.\n * It returns a function that takes one argument, passes it to the first UnaryFunction, and then\n * passes the result to the next one, passes that result to the next one, and so on.  \n */\nexport function pipe(...fns: Array<UnaryFunction<any, any>>): UnaryFunction<any, any> {\n  return pipeFromArray(fns);\n}\n\n/** @internal */\nexport function pipeFromArray<T, R>(fns: Array<UnaryFunction<T, R>>): UnaryFunction<T, R> {\n  if (fns.length === 0) {\n    return identity as UnaryFunction<any, any>;\n  }\n\n  if (fns.length === 1) {\n    return fns[0];\n  }\n\n  return function piped(input: T): R {\n    return fns.reduce((prev: any, fn: UnaryFunction<T, R>) => fn(prev), input as any);\n  };\n}\n","import { config } from '../config';\nimport { timeoutProvider } from '../scheduler/timeoutProvider';\n\n/**\n * Handles an error on another job either with the user-configured {@link onUnhandledError},\n * or by throwing it on that new job so it can be picked up by `window.onerror`, `process.on('error')`, etc.\n *\n * This should be called whenever there is an error that is out-of-band with the subscription\n * or when an error hits a terminal boundary of the subscription and no error handler was provided.\n *\n * @param err the error to report\n */\nexport function reportUnhandledError(err: any) {\n  timeoutProvider.setTimeout(() => {\n    const { onUnhandledError } = config;\n    if (onUnhandledError) {\n      // Execute the user-configured error handler.\n      onUnhandledError(err);\n    } else {\n      // Throw so it is picked up by the runtime's uncaught error mechanism.\n      throw err;\n    }\n  });\n}\n"],"names":["COMPLETE_NOTIFICATION","createNotification","undefined","errorNotification","error","nextNotification","value","kind","SafeSubscriber","Subscriber","isSubscription","observable","Symbol_observable","pipeFromArray","config","isFunction","errorContext","Observable","constructor","subscribe","_subscribe","lift","operator","source","observerOrNext","complete","subscriber","isSubscriber","add","call","_trySubscribe","sink","err","forEach","next","promiseCtor","getPromiseCtor","resolve","reject","unsubscribe","pipe","operations","toPromise","x","Promise","isObserver","Subscription","reportUnhandledError","noop","timeoutProvider","captureError","destination","EMPTY_OBSERVER","create","isStopped","handleStoppedNotification","_next","_error","_complete","closed","_bind","Function","prototype","bind","fn","thisArg","ConsumerObserver","partialObserver","handleUnhandledError","context","useDeprecatedNextContext","Object","useDeprecatedSynchronousErrorHandling","defaultErrorHandler","notification","onStoppedNotification","setTimeout","UnsubscriptionError","arrRemove","initialTeardown","errors","_parentage","Array","isArray","parent","remove","initialFinalizer","e","_finalizers","finalizer","execFinalizer","push","teardown","_hasParent","_addParent","includes","_removeParent","empty","EMPTY_SUBSCRIPTION","EMPTY","onUnhandledError","handler","timeout","args","delegate","clearTimeout","handle","Symbol","createErrorClass","_super","UnsubscriptionErrorImpl","message","length","map","i","toString","join","name","arr","item","index","indexOf","splice","createImpl","instance","Error","stack","ctorFunc","cb","isRoot","errorThrown","identity","fns","piped","input","reduce","prev"],"sourceRoot":"webpack:///","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]}