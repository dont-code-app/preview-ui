{"version":3,"file":"default-common_temp_node_modules_pnpm_rxjs_7_8_1_node_modules_rxjs_dist_esm_internal_Subject_-2a3d1f.js","mappings":"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","sources":["../../common/temp/node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/Subject.ts","../../common/temp/node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/observable/combineLatest.ts","../../common/temp/node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/observable/empty.ts","../../common/temp/node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/observable/of.ts","../../common/temp/node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/catchError.ts","../../common/temp/node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/mergeAll.ts","../../common/temp/node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/mergeInternals.ts","../../common/temp/node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/mergeMap.ts","../../common/temp/node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/util/EmptyError.ts","../../common/temp/node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/util/ObjectUnsubscribedError.ts","../../common/temp/node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/util/args.ts","../../common/temp/node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/util/argsArgArrayOrObject.ts","../../common/temp/node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/util/createObject.ts","../../common/temp/node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/util/mapOneOrManyArgs.ts"],"sourcesContent":["import { Operator } from './Operator';\nimport { Observable } from './Observable';\nimport { Subscriber } from './Subscriber';\nimport { Subscription, EMPTY_SUBSCRIPTION } from './Subscription';\nimport { Observer, SubscriptionLike, TeardownLogic } from './types';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\nimport { arrRemove } from './util/arrRemove';\nimport { errorContext } from './util/errorContext';\n\n/**\n * A Subject is a special type of Observable that allows values to be\n * multicasted to many Observers. Subjects are like EventEmitters.\n *\n * Every Subject is an Observable and an Observer. You can subscribe to a\n * Subject, and you can call next to feed values as well as error and complete.\n */\nexport class Subject<T> extends Observable<T> implements SubscriptionLike {\n  closed = false;\n\n  private currentObservers: Observer<T>[] | null = null;\n\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  observers: Observer<T>[] = [];\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  isStopped = false;\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  hasError = false;\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  thrownError: any = null;\n\n  /**\n   * Creates a \"subject\" by basically gluing an observer to an observable.\n   *\n   * @nocollapse\n   * @deprecated Recommended you do not use. Will be removed at some point in the future. Plans for replacement still under discussion.\n   */\n  static create: (...args: any[]) => any = <T>(destination: Observer<T>, source: Observable<T>): AnonymousSubject<T> => {\n    return new AnonymousSubject<T>(destination, source);\n  };\n\n  constructor() {\n    // NOTE: This must be here to obscure Observable's constructor.\n    super();\n  }\n\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  lift<R>(operator: Operator<T, R>): Observable<R> {\n    const subject = new AnonymousSubject(this, this);\n    subject.operator = operator as any;\n    return subject as any;\n  }\n\n  /** @internal */\n  protected _throwIfClosed() {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    }\n  }\n\n  next(value: T) {\n    errorContext(() => {\n      this._throwIfClosed();\n      if (!this.isStopped) {\n        if (!this.currentObservers) {\n          this.currentObservers = Array.from(this.observers);\n        }\n        for (const observer of this.currentObservers) {\n          observer.next(value);\n        }\n      }\n    });\n  }\n\n  error(err: any) {\n    errorContext(() => {\n      this._throwIfClosed();\n      if (!this.isStopped) {\n        this.hasError = this.isStopped = true;\n        this.thrownError = err;\n        const { observers } = this;\n        while (observers.length) {\n          observers.shift()!.error(err);\n        }\n      }\n    });\n  }\n\n  complete() {\n    errorContext(() => {\n      this._throwIfClosed();\n      if (!this.isStopped) {\n        this.isStopped = true;\n        const { observers } = this;\n        while (observers.length) {\n          observers.shift()!.complete();\n        }\n      }\n    });\n  }\n\n  unsubscribe() {\n    this.isStopped = this.closed = true;\n    this.observers = this.currentObservers = null!;\n  }\n\n  get observed() {\n    return this.observers?.length > 0;\n  }\n\n  /** @internal */\n  protected _trySubscribe(subscriber: Subscriber<T>): TeardownLogic {\n    this._throwIfClosed();\n    return super._trySubscribe(subscriber);\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<T>): Subscription {\n    this._throwIfClosed();\n    this._checkFinalizedStatuses(subscriber);\n    return this._innerSubscribe(subscriber);\n  }\n\n  /** @internal */\n  protected _innerSubscribe(subscriber: Subscriber<any>) {\n    const { hasError, isStopped, observers } = this;\n    if (hasError || isStopped) {\n      return EMPTY_SUBSCRIPTION;\n    }\n    this.currentObservers = null;\n    observers.push(subscriber);\n    return new Subscription(() => {\n      this.currentObservers = null;\n      arrRemove(observers, subscriber);\n    });\n  }\n\n  /** @internal */\n  protected _checkFinalizedStatuses(subscriber: Subscriber<any>) {\n    const { hasError, thrownError, isStopped } = this;\n    if (hasError) {\n      subscriber.error(thrownError);\n    } else if (isStopped) {\n      subscriber.complete();\n    }\n  }\n\n  /**\n   * Creates a new Observable with this Subject as the source. You can do this\n   * to create custom Observer-side logic of the Subject and conceal it from\n   * code that uses the Observable.\n   * @return {Observable} Observable that the Subject casts to\n   */\n  asObservable(): Observable<T> {\n    const observable: any = new Observable<T>();\n    observable.source = this;\n    return observable;\n  }\n}\n\n/**\n * @class AnonymousSubject<T>\n */\nexport class AnonymousSubject<T> extends Subject<T> {\n  constructor(\n    /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n    public destination?: Observer<T>,\n    source?: Observable<T>\n  ) {\n    super();\n    this.source = source;\n  }\n\n  next(value: T) {\n    this.destination?.next?.(value);\n  }\n\n  error(err: any) {\n    this.destination?.error?.(err);\n  }\n\n  complete() {\n    this.destination?.complete?.();\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<T>): Subscription {\n    return this.source?.subscribe(subscriber) ?? EMPTY_SUBSCRIPTION;\n  }\n}\n","import { Observable } from '../Observable';\nimport { ObservableInput, SchedulerLike, ObservedValueOf, ObservableInputTuple } from '../types';\nimport { argsArgArrayOrObject } from '../util/argsArgArrayOrObject';\nimport { Subscriber } from '../Subscriber';\nimport { from } from './from';\nimport { identity } from '../util/identity';\nimport { Subscription } from '../Subscription';\nimport { mapOneOrManyArgs } from '../util/mapOneOrManyArgs';\nimport { popResultSelector, popScheduler } from '../util/args';\nimport { createObject } from '../util/createObject';\nimport { createOperatorSubscriber } from '../operators/OperatorSubscriber';\nimport { AnyCatcher } from '../AnyCatcher';\nimport { executeSchedule } from '../util/executeSchedule';\n\n// combineLatest(any)\n// We put this first because we need to catch cases where the user has supplied\n// _exactly `any`_ as the argument. Since `any` literally matches _anything_,\n// we don't want it to randomly hit one of the other type signatures below,\n// as we have no idea at build-time what type we should be returning when given an any.\n\n/**\n * You have passed `any` here, we can't figure out if it is\n * an array or an object, so you're getting `unknown`. Use better types.\n * @param arg Something typed as `any`\n */\nexport function combineLatest<T extends AnyCatcher>(arg: T): Observable<unknown>;\n\n// combineLatest([a, b, c])\nexport function combineLatest(sources: []): Observable<never>;\nexport function combineLatest<A extends readonly unknown[]>(sources: readonly [...ObservableInputTuple<A>]): Observable<A>;\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled` and `combineLatestAll`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function combineLatest<A extends readonly unknown[], R>(\n  sources: readonly [...ObservableInputTuple<A>],\n  resultSelector: (...values: A) => R,\n  scheduler: SchedulerLike\n): Observable<R>;\nexport function combineLatest<A extends readonly unknown[], R>(\n  sources: readonly [...ObservableInputTuple<A>],\n  resultSelector: (...values: A) => R\n): Observable<R>;\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled` and `combineLatestAll`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function combineLatest<A extends readonly unknown[]>(\n  sources: readonly [...ObservableInputTuple<A>],\n  scheduler: SchedulerLike\n): Observable<A>;\n\n// combineLatest(a, b, c)\n/** @deprecated Pass an array of sources instead. The rest-parameters signature will be removed in v8. Details: https://rxjs.dev/deprecations/array-argument */\nexport function combineLatest<A extends readonly unknown[]>(...sources: [...ObservableInputTuple<A>]): Observable<A>;\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled` and `combineLatestAll`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function combineLatest<A extends readonly unknown[], R>(\n  ...sourcesAndResultSelectorAndScheduler: [...ObservableInputTuple<A>, (...values: A) => R, SchedulerLike]\n): Observable<R>;\n/** @deprecated Pass an array of sources instead. The rest-parameters signature will be removed in v8. Details: https://rxjs.dev/deprecations/array-argument */\nexport function combineLatest<A extends readonly unknown[], R>(\n  ...sourcesAndResultSelector: [...ObservableInputTuple<A>, (...values: A) => R]\n): Observable<R>;\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled` and `combineLatestAll`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function combineLatest<A extends readonly unknown[]>(\n  ...sourcesAndScheduler: [...ObservableInputTuple<A>, SchedulerLike]\n): Observable<A>;\n\n// combineLatest({a, b, c})\nexport function combineLatest(sourcesObject: { [K in any]: never }): Observable<never>;\nexport function combineLatest<T extends Record<string, ObservableInput<any>>>(\n  sourcesObject: T\n): Observable<{ [K in keyof T]: ObservedValueOf<T[K]> }>;\n\n/**\n * Combines multiple Observables to create an Observable whose values are\n * calculated from the latest values of each of its input Observables.\n *\n * <span class=\"informal\">Whenever any input Observable emits a value, it\n * computes a formula using the latest values from all the inputs, then emits\n * the output of that formula.</span>\n *\n * ![](combineLatest.png)\n *\n * `combineLatest` combines the values from all the Observables passed in the\n * observables array. This is done by subscribing to each Observable in order and,\n * whenever any Observable emits, collecting an array of the most recent\n * values from each Observable. So if you pass `n` Observables to this operator,\n * the returned Observable will always emit an array of `n` values, in an order\n * corresponding to the order of the passed Observables (the value from the first Observable\n * will be at index 0 of the array and so on).\n *\n * Static version of `combineLatest` accepts an array of Observables. Note that an array of\n * Observables is a good choice, if you don't know beforehand how many Observables\n * you will combine. Passing an empty array will result in an Observable that\n * completes immediately.\n *\n * To ensure the output array always has the same length, `combineLatest` will\n * actually wait for all input Observables to emit at least once,\n * before it starts emitting results. This means if some Observable emits\n * values before other Observables started emitting, all these values but the last\n * will be lost. On the other hand, if some Observable does not emit a value but\n * completes, resulting Observable will complete at the same moment without\n * emitting anything, since it will now be impossible to include a value from the\n * completed Observable in the resulting array. Also, if some input Observable does\n * not emit any value and never completes, `combineLatest` will also never emit\n * and never complete, since, again, it will wait for all streams to emit some\n * value.\n *\n * If at least one Observable was passed to `combineLatest` and all passed Observables\n * emitted something, the resulting Observable will complete when all combined\n * streams complete. So even if some Observable completes, the result of\n * `combineLatest` will still emit values when other Observables do. In case\n * of a completed Observable, its value from now on will always be the last\n * emitted value. On the other hand, if any Observable errors, `combineLatest`\n * will error immediately as well, and all other Observables will be unsubscribed.\n *\n * ## Examples\n *\n * Combine two timer Observables\n *\n * ```ts\n * import { timer, combineLatest } from 'rxjs';\n *\n * const firstTimer = timer(0, 1000); // emit 0, 1, 2... after every second, starting from now\n * const secondTimer = timer(500, 1000); // emit 0, 1, 2... after every second, starting 0,5s from now\n * const combinedTimers = combineLatest([firstTimer, secondTimer]);\n * combinedTimers.subscribe(value => console.log(value));\n * // Logs\n * // [0, 0] after 0.5s\n * // [1, 0] after 1s\n * // [1, 1] after 1.5s\n * // [2, 1] after 2s\n * ```\n *\n * Combine a dictionary of Observables\n *\n * ```ts\n * import { of, delay, startWith, combineLatest } from 'rxjs';\n *\n * const observables = {\n *   a: of(1).pipe(delay(1000), startWith(0)),\n *   b: of(5).pipe(delay(5000), startWith(0)),\n *   c: of(10).pipe(delay(10000), startWith(0))\n * };\n * const combined = combineLatest(observables);\n * combined.subscribe(value => console.log(value));\n * // Logs\n * // { a: 0, b: 0, c: 0 } immediately\n * // { a: 1, b: 0, c: 0 } after 1s\n * // { a: 1, b: 5, c: 0 } after 5s\n * // { a: 1, b: 5, c: 10 } after 10s\n * ```\n *\n * Combine an array of Observables\n *\n * ```ts\n * import { of, delay, startWith, combineLatest } from 'rxjs';\n *\n * const observables = [1, 5, 10].map(\n *   n => of(n).pipe(\n *     delay(n * 1000), // emit 0 and then emit n after n seconds\n *     startWith(0)\n *   )\n * );\n * const combined = combineLatest(observables);\n * combined.subscribe(value => console.log(value));\n * // Logs\n * // [0, 0, 0] immediately\n * // [1, 0, 0] after 1s\n * // [1, 5, 0] after 5s\n * // [1, 5, 10] after 10s\n * ```\n *\n * Use map operator to dynamically calculate the Body-Mass Index\n *\n * ```ts\n * import { of, combineLatest, map } from 'rxjs';\n *\n * const weight = of(70, 72, 76, 79, 75);\n * const height = of(1.76, 1.77, 1.78);\n * const bmi = combineLatest([weight, height]).pipe(\n *   map(([w, h]) => w / (h * h)),\n * );\n * bmi.subscribe(x => console.log('BMI is ' + x));\n *\n * // With output to console:\n * // BMI is 24.212293388429753\n * // BMI is 23.93948099205209\n * // BMI is 23.671253629592222\n * ```\n *\n * @see {@link combineLatestAll}\n * @see {@link merge}\n * @see {@link withLatestFrom}\n *\n * @param {ObservableInput} [observables] An array of input Observables to combine with each other.\n * An array of Observables must be given as the first argument.\n * @param {function} [project] An optional function to project the values from\n * the combined latest values into a new value on the output Observable.\n * @param {SchedulerLike} [scheduler=null] The {@link SchedulerLike} to use for subscribing to\n * each input Observable.\n * @return {Observable} An Observable of projected values from the most recent\n * values from each input Observable, or an array of the most recent values from\n * each input Observable.\n */\nexport function combineLatest<O extends ObservableInput<any>, R>(...args: any[]): Observable<R> | Observable<ObservedValueOf<O>[]> {\n  const scheduler = popScheduler(args);\n  const resultSelector = popResultSelector(args);\n\n  const { args: observables, keys } = argsArgArrayOrObject(args);\n\n  if (observables.length === 0) {\n    // If no observables are passed, or someone has passed an empty array\n    // of observables, or even an empty object POJO, we need to just\n    // complete (EMPTY), but we have to honor the scheduler provided if any.\n    return from([], scheduler as any);\n  }\n\n  const result = new Observable<ObservedValueOf<O>[]>(\n    combineLatestInit(\n      observables as ObservableInput<ObservedValueOf<O>>[],\n      scheduler,\n      keys\n        ? // A handler for scrubbing the array of args into a dictionary.\n          (values) => createObject(keys, values)\n        : // A passthrough to just return the array\n          identity\n    )\n  );\n\n  return resultSelector ? (result.pipe(mapOneOrManyArgs(resultSelector)) as Observable<R>) : result;\n}\n\nexport function combineLatestInit(\n  observables: ObservableInput<any>[],\n  scheduler?: SchedulerLike,\n  valueTransform: (values: any[]) => any = identity\n) {\n  return (subscriber: Subscriber<any>) => {\n    // The outer subscription. We're capturing this in a function\n    // because we may have to schedule it.\n    maybeSchedule(\n      scheduler,\n      () => {\n        const { length } = observables;\n        // A store for the values each observable has emitted so far. We match observable to value on index.\n        const values = new Array(length);\n        // The number of currently active subscriptions, as they complete, we decrement this number to see if\n        // we are all done combining values, so we can complete the result.\n        let active = length;\n        // The number of inner sources that still haven't emitted the first value\n        // We need to track this because all sources need to emit one value in order\n        // to start emitting values.\n        let remainingFirstValues = length;\n        // The loop to kick off subscription. We're keying everything on index `i` to relate the observables passed\n        // in to the slot in the output array or the key in the array of keys in the output dictionary.\n        for (let i = 0; i < length; i++) {\n          maybeSchedule(\n            scheduler,\n            () => {\n              const source = from(observables[i], scheduler as any);\n              let hasFirstValue = false;\n              source.subscribe(\n                createOperatorSubscriber(\n                  subscriber,\n                  (value) => {\n                    // When we get a value, record it in our set of values.\n                    values[i] = value;\n                    if (!hasFirstValue) {\n                      // If this is our first value, record that.\n                      hasFirstValue = true;\n                      remainingFirstValues--;\n                    }\n                    if (!remainingFirstValues) {\n                      // We're not waiting for any more\n                      // first values, so we can emit!\n                      subscriber.next(valueTransform(values.slice()));\n                    }\n                  },\n                  () => {\n                    if (!--active) {\n                      // We only complete the result if we have no more active\n                      // inner observables.\n                      subscriber.complete();\n                    }\n                  }\n                )\n              );\n            },\n            subscriber\n          );\n        }\n      },\n      subscriber\n    );\n  };\n}\n\n/**\n * A small utility to handle the couple of locations where we want to schedule if a scheduler was provided,\n * but we don't if there was no scheduler.\n */\nfunction maybeSchedule(scheduler: SchedulerLike | undefined, execute: () => void, subscription: Subscription) {\n  if (scheduler) {\n    executeSchedule(subscription, scheduler, execute);\n  } else {\n    execute();\n  }\n}\n","import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\n\n/**\n * A simple Observable that emits no items to the Observer and immediately\n * emits a complete notification.\n *\n * <span class=\"informal\">Just emits 'complete', and nothing else.</span>\n *\n * ![](empty.png)\n *\n * A simple Observable that only emits the complete notification. It can be used\n * for composing with other Observables, such as in a {@link mergeMap}.\n *\n * ## Examples\n *\n * Log complete notification\n *\n * ```ts\n * import { EMPTY } from 'rxjs';\n *\n * EMPTY.subscribe({\n *   next: () => console.log('Next'),\n *   complete: () => console.log('Complete!')\n * });\n *\n * // Outputs\n * // Complete!\n * ```\n *\n * Emit the number 7, then complete\n *\n * ```ts\n * import { EMPTY, startWith } from 'rxjs';\n *\n * const result = EMPTY.pipe(startWith(7));\n * result.subscribe(x => console.log(x));\n *\n * // Outputs\n * // 7\n * ```\n *\n * Map and flatten only odd numbers to the sequence `'a'`, `'b'`, `'c'`\n *\n * ```ts\n * import { interval, mergeMap, of, EMPTY } from 'rxjs';\n *\n * const interval$ = interval(1000);\n * const result = interval$.pipe(\n *   mergeMap(x => x % 2 === 1 ? of('a', 'b', 'c') : EMPTY),\n * );\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following to the console:\n * // x is equal to the count on the interval, e.g. (0, 1, 2, 3, ...)\n * // x will occur every 1000ms\n * // if x % 2 is equal to 1, print a, b, c (each on its own)\n * // if x % 2 is not equal to 1, nothing will be output\n * ```\n *\n * @see {@link Observable}\n * @see {@link NEVER}\n * @see {@link of}\n * @see {@link throwError}\n */\nexport const EMPTY = new Observable<never>((subscriber) => subscriber.complete());\n\n/**\n * @param scheduler A {@link SchedulerLike} to use for scheduling\n * the emission of the complete notification.\n * @deprecated Replaced with the {@link EMPTY} constant or {@link scheduled} (e.g. `scheduled([], scheduler)`). Will be removed in v8.\n */\nexport function empty(scheduler?: SchedulerLike) {\n  return scheduler ? emptyScheduled(scheduler) : EMPTY;\n}\n\nfunction emptyScheduled(scheduler: SchedulerLike) {\n  return new Observable<never>((subscriber) => scheduler.schedule(() => subscriber.complete()));\n}\n","import { SchedulerLike, ValueFromArray } from '../types';\nimport { Observable } from '../Observable';\nimport { popScheduler } from '../util/args';\nimport { from } from './from';\n\n// Devs are more likely to pass null or undefined than they are a scheduler\n// without accompanying values. To make things easier for (naughty) devs who\n// use the `strictNullChecks: false` TypeScript compiler option, these\n// overloads with explicit null and undefined values are included.\n\nexport function of(value: null): Observable<null>;\nexport function of(value: undefined): Observable<undefined>;\n\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function of(scheduler: SchedulerLike): Observable<never>;\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function of<A extends readonly unknown[]>(...valuesAndScheduler: [...A, SchedulerLike]): Observable<ValueFromArray<A>>;\n\nexport function of(): Observable<never>;\n/** @deprecated Do not specify explicit type parameters. Signatures with type parameters that cannot be inferred will be removed in v8. */\nexport function of<T>(): Observable<T>;\nexport function of<T>(value: T): Observable<T>;\nexport function of<A extends readonly unknown[]>(...values: A): Observable<ValueFromArray<A>>;\n\n/**\n * Converts the arguments to an observable sequence.\n *\n * <span class=\"informal\">Each argument becomes a `next` notification.</span>\n *\n * ![](of.png)\n *\n * Unlike {@link from}, it does not do any flattening and emits each argument in whole\n * as a separate `next` notification.\n *\n * ## Examples\n *\n * Emit the values `10, 20, 30`\n *\n * ```ts\n * import { of } from 'rxjs';\n *\n * of(10, 20, 30)\n *   .subscribe({\n *     next: value => console.log('next:', value),\n *     error: err => console.log('error:', err),\n *     complete: () => console.log('the end'),\n *   });\n *\n * // Outputs\n * // next: 10\n * // next: 20\n * // next: 30\n * // the end\n * ```\n *\n * Emit the array `[1, 2, 3]`\n *\n * ```ts\n * import { of } from 'rxjs';\n *\n * of([1, 2, 3])\n *   .subscribe({\n *     next: value => console.log('next:', value),\n *     error: err => console.log('error:', err),\n *     complete: () => console.log('the end'),\n *   });\n *\n * // Outputs\n * // next: [1, 2, 3]\n * // the end\n * ```\n *\n * @see {@link from}\n * @see {@link range}\n *\n * @param {...T} values A comma separated list of arguments you want to be emitted\n * @return {Observable} An Observable that emits the arguments\n * described above and then completes.\n */\nexport function of<T>(...args: Array<T | SchedulerLike>): Observable<T> {\n  const scheduler = popScheduler(args);\n  return from(args as T[], scheduler);\n}\n","import { Observable } from '../Observable';\n\nimport { ObservableInput, OperatorFunction, ObservedValueOf } from '../types';\nimport { Subscription } from '../Subscription';\nimport { innerFrom } from '../observable/innerFrom';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { operate } from '../util/lift';\n\n/* tslint:disable:max-line-length */\nexport function catchError<T, O extends ObservableInput<any>>(\n  selector: (err: any, caught: Observable<T>) => O\n): OperatorFunction<T, T | ObservedValueOf<O>>;\n/* tslint:enable:max-line-length */\n\n/**\n * Catches errors on the observable to be handled by returning a new observable or throwing an error.\n *\n * <span class=\"informal\">\n * It only listens to the error channel and ignores notifications.\n * Handles errors from the source observable, and maps them to a new observable.\n * The error may also be rethrown, or a new error can be thrown to emit an error from the result.\n * </span>\n *\n * ![](catch.png)\n *\n * This operator handles errors, but forwards along all other events to the resulting observable.\n * If the source observable terminates with an error, it will map that error to a new observable,\n * subscribe to it, and forward all of its events to the resulting observable.\n *\n * ## Examples\n *\n * Continue with a different Observable when there's an error\n *\n * ```ts\n * import { of, map, catchError } from 'rxjs';\n *\n * of(1, 2, 3, 4, 5)\n *   .pipe(\n *     map(n => {\n *       if (n === 4) {\n *         throw 'four!';\n *       }\n *       return n;\n *     }),\n *     catchError(err => of('I', 'II', 'III', 'IV', 'V'))\n *   )\n *   .subscribe(x => console.log(x));\n *   // 1, 2, 3, I, II, III, IV, V\n * ```\n *\n * Retry the caught source Observable again in case of error, similar to `retry()` operator\n *\n * ```ts\n * import { of, map, catchError, take } from 'rxjs';\n *\n * of(1, 2, 3, 4, 5)\n *   .pipe(\n *     map(n => {\n *       if (n === 4) {\n *         throw 'four!';\n *       }\n *       return n;\n *     }),\n *     catchError((err, caught) => caught),\n *     take(30)\n *   )\n *   .subscribe(x => console.log(x));\n *   // 1, 2, 3, 1, 2, 3, ...\n * ```\n *\n * Throw a new error when the source Observable throws an error\n *\n * ```ts\n * import { of, map, catchError } from 'rxjs';\n *\n * of(1, 2, 3, 4, 5)\n *   .pipe(\n *     map(n => {\n *       if (n === 4) {\n *         throw 'four!';\n *       }\n *       return n;\n *     }),\n *     catchError(err => {\n *       throw 'error in source. Details: ' + err;\n *     })\n *   )\n *   .subscribe({\n *     next: x => console.log(x),\n *     error: err => console.log(err)\n *   });\n *   // 1, 2, 3, error in source. Details: four!\n * ```\n *\n * @see {@link onErrorResumeNext}\n * @see {@link repeat}\n * @see {@link repeatWhen}\n * @see {@link retry }\n * @see {@link retryWhen}\n *\n * @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which\n * is the source observable, in case you'd like to \"retry\" that observable by returning it again. Whatever observable\n * is returned by the `selector` will be used to continue the observable chain.\n * @return A function that returns an Observable that originates from either\n * the source or the Observable returned by the `selector` function.\n */\nexport function catchError<T, O extends ObservableInput<any>>(\n  selector: (err: any, caught: Observable<T>) => O\n): OperatorFunction<T, T | ObservedValueOf<O>> {\n  return operate((source, subscriber) => {\n    let innerSub: Subscription | null = null;\n    let syncUnsub = false;\n    let handledResult: Observable<ObservedValueOf<O>>;\n\n    innerSub = source.subscribe(\n      createOperatorSubscriber(subscriber, undefined, undefined, (err) => {\n        handledResult = innerFrom(selector(err, catchError(selector)(source)));\n        if (innerSub) {\n          innerSub.unsubscribe();\n          innerSub = null;\n          handledResult.subscribe(subscriber);\n        } else {\n          // We don't have an innerSub yet, that means the error was synchronous\n          // because the subscribe call hasn't returned yet.\n          syncUnsub = true;\n        }\n      })\n    );\n\n    if (syncUnsub) {\n      // We have a synchronous error, we need to make sure to\n      // finalize right away. This ensures that callbacks in the `finalize` operator are called\n      // at the right time, and that finalization occurs at the expected\n      // time between the source error and the subscription to the\n      // next observable.\n      innerSub.unsubscribe();\n      innerSub = null;\n      handledResult!.subscribe(subscriber);\n    }\n  });\n}\n","import { mergeMap } from './mergeMap';\nimport { identity } from '../util/identity';\nimport { OperatorFunction, ObservableInput, ObservedValueOf } from '../types';\n\n/**\n * Converts a higher-order Observable into a first-order Observable which\n * concurrently delivers all values that are emitted on the inner Observables.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables.</span>\n *\n * ![](mergeAll.png)\n *\n * `mergeAll` subscribes to an Observable that emits Observables, also known as\n * a higher-order Observable. Each time it observes one of these emitted inner\n * Observables, it subscribes to that and delivers all the values from the\n * inner Observable on the output Observable. The output Observable only\n * completes once all inner Observables have completed. Any error delivered by\n * a inner Observable will be immediately emitted on the output Observable.\n *\n * ## Examples\n *\n * Spawn a new interval Observable for each click event, and blend their outputs as one Observable\n *\n * ```ts\n * import { fromEvent, map, interval, mergeAll } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const higherOrder = clicks.pipe(map(() => interval(1000)));\n * const firstOrder = higherOrder.pipe(mergeAll());\n *\n * firstOrder.subscribe(x => console.log(x));\n * ```\n *\n * Count from 0 to 9 every second for each click, but only allow 2 concurrent timers\n *\n * ```ts\n * import { fromEvent, map, interval, take, mergeAll } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const higherOrder = clicks.pipe(\n *   map(() => interval(1000).pipe(take(10)))\n * );\n * const firstOrder = higherOrder.pipe(mergeAll(2));\n *\n * firstOrder.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link combineLatestAll}\n * @see {@link concatAll}\n * @see {@link exhaustAll}\n * @see {@link merge}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n * @see {@link switchAll}\n * @see {@link switchMap}\n * @see {@link zipAll}\n *\n * @param {number} [concurrent=Infinity] Maximum number of inner\n * Observables being subscribed to concurrently.\n * @return A function that returns an Observable that emits values coming from\n * all the inner Observables emitted by the source Observable.\n */\nexport function mergeAll<O extends ObservableInput<any>>(concurrent: number = Infinity): OperatorFunction<O, ObservedValueOf<O>> {\n  return mergeMap(identity, concurrent);\n}\n","import { Observable } from '../Observable';\nimport { innerFrom } from '../observable/innerFrom';\nimport { Subscriber } from '../Subscriber';\nimport { ObservableInput, SchedulerLike } from '../types';\nimport { executeSchedule } from '../util/executeSchedule';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * A process embodying the general \"merge\" strategy. This is used in\n * `mergeMap` and `mergeScan` because the logic is otherwise nearly identical.\n * @param source The original source observable\n * @param subscriber The consumer subscriber\n * @param project The projection function to get our inner sources\n * @param concurrent The number of concurrent inner subscriptions\n * @param onBeforeNext Additional logic to apply before nexting to our consumer\n * @param expand If `true` this will perform an \"expand\" strategy, which differs only\n * in that it recurses, and the inner subscription must be schedule-able.\n * @param innerSubScheduler A scheduler to use to schedule inner subscriptions,\n * this is to support the expand strategy, mostly, and should be deprecated\n */\nexport function mergeInternals<T, R>(\n  source: Observable<T>,\n  subscriber: Subscriber<R>,\n  project: (value: T, index: number) => ObservableInput<R>,\n  concurrent: number,\n  onBeforeNext?: (innerValue: R) => void,\n  expand?: boolean,\n  innerSubScheduler?: SchedulerLike,\n  additionalFinalizer?: () => void\n) {\n  // Buffered values, in the event of going over our concurrency limit\n  const buffer: T[] = [];\n  // The number of active inner subscriptions.\n  let active = 0;\n  // An index to pass to our accumulator function\n  let index = 0;\n  // Whether or not the outer source has completed.\n  let isComplete = false;\n\n  /**\n   * Checks to see if we can complete our result or not.\n   */\n  const checkComplete = () => {\n    // If the outer has completed, and nothing is left in the buffer,\n    // and we don't have any active inner subscriptions, then we can\n    // Emit the state and complete.\n    if (isComplete && !buffer.length && !active) {\n      subscriber.complete();\n    }\n  };\n\n  // If we're under our concurrency limit, just start the inner subscription, otherwise buffer and wait.\n  const outerNext = (value: T) => (active < concurrent ? doInnerSub(value) : buffer.push(value));\n\n  const doInnerSub = (value: T) => {\n    // If we're expanding, we need to emit the outer values and the inner values\n    // as the inners will \"become outers\" in a way as they are recursively fed\n    // back to the projection mechanism.\n    expand && subscriber.next(value as any);\n\n    // Increment the number of active subscriptions so we can track it\n    // against our concurrency limit later.\n    active++;\n\n    // A flag used to show that the inner observable completed.\n    // This is checked during finalization to see if we should\n    // move to the next item in the buffer, if there is on.\n    let innerComplete = false;\n\n    // Start our inner subscription.\n    innerFrom(project(value, index++)).subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (innerValue) => {\n          // `mergeScan` has additional handling here. For example\n          // taking the inner value and updating state.\n          onBeforeNext?.(innerValue);\n\n          if (expand) {\n            // If we're expanding, then just recurse back to our outer\n            // handler. It will emit the value first thing.\n            outerNext(innerValue as any);\n          } else {\n            // Otherwise, emit the inner value.\n            subscriber.next(innerValue);\n          }\n        },\n        () => {\n          // Flag that we have completed, so we know to check the buffer\n          // during finalization.\n          innerComplete = true;\n        },\n        // Errors are passed to the destination.\n        undefined,\n        () => {\n          // During finalization, if the inner completed (it wasn't errored or\n          // cancelled), then we want to try the next item in the buffer if\n          // there is one.\n          if (innerComplete) {\n            // We have to wrap this in a try/catch because it happens during\n            // finalization, possibly asynchronously, and we want to pass\n            // any errors that happen (like in a projection function) to\n            // the outer Subscriber.\n            try {\n              // INNER SOURCE COMPLETE\n              // Decrement the active count to ensure that the next time\n              // we try to call `doInnerSub`, the number is accurate.\n              active--;\n              // If we have more values in the buffer, try to process those\n              // Note that this call will increment `active` ahead of the\n              // next conditional, if there were any more inner subscriptions\n              // to start.\n              while (buffer.length && active < concurrent) {\n                const bufferedValue = buffer.shift()!;\n                // Particularly for `expand`, we need to check to see if a scheduler was provided\n                // for when we want to start our inner subscription. Otherwise, we just start\n                // are next inner subscription.\n                if (innerSubScheduler) {\n                  executeSchedule(subscriber, innerSubScheduler, () => doInnerSub(bufferedValue));\n                } else {\n                  doInnerSub(bufferedValue);\n                }\n              }\n              // Check to see if we can complete, and complete if so.\n              checkComplete();\n            } catch (err) {\n              subscriber.error(err);\n            }\n          }\n        }\n      )\n    );\n  };\n\n  // Subscribe to our source observable.\n  source.subscribe(\n    createOperatorSubscriber(subscriber, outerNext, () => {\n      // Outer completed, make a note of it, and check to see if we can complete everything.\n      isComplete = true;\n      checkComplete();\n    })\n  );\n\n  // Additional finalization (for when the destination is torn down).\n  // Other finalization is added implicitly via subscription above.\n  return () => {\n    additionalFinalizer?.();\n  };\n}\n","import { ObservableInput, OperatorFunction, ObservedValueOf } from '../types';\nimport { map } from './map';\nimport { innerFrom } from '../observable/innerFrom';\nimport { operate } from '../util/lift';\nimport { mergeInternals } from './mergeInternals';\nimport { isFunction } from '../util/isFunction';\n\n/* tslint:disable:max-line-length */\nexport function mergeMap<T, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  concurrent?: number\n): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\nexport function mergeMap<T, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector: undefined,\n  concurrent?: number\n): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\nexport function mergeMap<T, R, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R,\n  concurrent?: number\n): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link mergeAll}.</span>\n *\n * ![](mergeMap.png)\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an Observable, and then merging those resulting Observables and\n * emitting the results of this merger.\n *\n * ## Example\n *\n * Map and flatten each letter to an Observable ticking every 1 second\n *\n * ```ts\n * import { of, mergeMap, interval, map } from 'rxjs';\n *\n * const letters = of('a', 'b', 'c');\n * const result = letters.pipe(\n *   mergeMap(x => interval(1000).pipe(map(i => x + i)))\n * );\n *\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // a0\n * // b0\n * // c0\n * // a1\n * // b1\n * // c1\n * // continues to list a, b, c every second with respective ascending integers\n * ```\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link merge}\n * @see {@link mergeAll}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {number} [concurrent=Infinity] Maximum number of input\n * Observables being subscribed to concurrently.\n * @return A function that returns an Observable that emits the result of\n * applying the projection function (and the optional deprecated\n * `resultSelector`) to each item emitted by the source Observable and merging\n * the results of the Observables obtained from this transformation.\n */\nexport function mergeMap<T, R, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector?: ((outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R) | number,\n  concurrent: number = Infinity\n): OperatorFunction<T, ObservedValueOf<O> | R> {\n  if (isFunction(resultSelector)) {\n    // DEPRECATED PATH\n    return mergeMap((a, i) => map((b: any, ii: number) => resultSelector(a, b, i, ii))(innerFrom(project(a, i))), concurrent);\n  } else if (typeof resultSelector === 'number') {\n    concurrent = resultSelector;\n  }\n\n  return operate((source, subscriber) => mergeInternals(source, subscriber, project, concurrent));\n}\n","import { createErrorClass } from './createErrorClass';\n\nexport interface EmptyError extends Error {}\n\nexport interface EmptyErrorCtor {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  new (): EmptyError;\n}\n\n/**\n * An error thrown when an Observable or a sequence was queried but has no\n * elements.\n *\n * @see {@link first}\n * @see {@link last}\n * @see {@link single}\n * @see {@link firstValueFrom}\n * @see {@link lastValueFrom}\n *\n * @class EmptyError\n */\nexport const EmptyError: EmptyErrorCtor = createErrorClass((_super) => function EmptyErrorImpl(this: any) {\n  _super(this);\n  this.name = 'EmptyError';\n  this.message = 'no elements in sequence';\n});\n","import { createErrorClass } from './createErrorClass';\n\nexport interface ObjectUnsubscribedError extends Error {}\n\nexport interface ObjectUnsubscribedErrorCtor {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  new (): ObjectUnsubscribedError;\n}\n\n/**\n * An error thrown when an action is invalid because the object has been\n * unsubscribed.\n *\n * @see {@link Subject}\n * @see {@link BehaviorSubject}\n *\n * @class ObjectUnsubscribedError\n */\nexport const ObjectUnsubscribedError: ObjectUnsubscribedErrorCtor = createErrorClass(\n  (_super) =>\n    function ObjectUnsubscribedErrorImpl(this: any) {\n      _super(this);\n      this.name = 'ObjectUnsubscribedError';\n      this.message = 'object unsubscribed';\n    }\n);\n","import { SchedulerLike } from '../types';\nimport { isFunction } from './isFunction';\nimport { isScheduler } from './isScheduler';\n\nfunction last<T>(arr: T[]): T | undefined {\n  return arr[arr.length - 1];\n}\n\nexport function popResultSelector(args: any[]): ((...args: unknown[]) => unknown) | undefined {\n  return isFunction(last(args)) ? args.pop() : undefined;\n}\n\nexport function popScheduler(args: any[]): SchedulerLike | undefined {\n  return isScheduler(last(args)) ? args.pop() : undefined;\n}\n\nexport function popNumber(args: any[], defaultValue: number): number {\n  return typeof last(args) === 'number' ? args.pop()! : defaultValue;\n}\n","const { isArray } = Array;\nconst { getPrototypeOf, prototype: objectProto, keys: getKeys } = Object;\n\n/**\n * Used in functions where either a list of arguments, a single array of arguments, or a\n * dictionary of arguments can be returned. Returns an object with an `args` property with\n * the arguments in an array, if it is a dictionary, it will also return the `keys` in another\n * property.\n */\nexport function argsArgArrayOrObject<T, O extends Record<string, T>>(args: T[] | [O] | [T[]]): { args: T[]; keys: string[] | null } {\n  if (args.length === 1) {\n    const first = args[0];\n    if (isArray(first)) {\n      return { args: first, keys: null };\n    }\n    if (isPOJO(first)) {\n      const keys = getKeys(first);\n      return {\n        args: keys.map((key) => first[key]),\n        keys,\n      };\n    }\n  }\n\n  return { args: args as T[], keys: null };\n}\n\nfunction isPOJO(obj: any): obj is object {\n  return obj && typeof obj === 'object' && getPrototypeOf(obj) === objectProto;\n}\n","export function createObject(keys: string[], values: any[]) {\n  return keys.reduce((result, key, i) => ((result[key] = values[i]), result), {} as any);\n}\n","import { OperatorFunction } from \"../types\";\nimport { map } from \"../operators/map\";\n\nconst { isArray } = Array;\n\nfunction callOrApply<T, R>(fn: ((...values: T[]) => R), args: T|T[]): R {\n    return isArray(args) ? fn(...args) : fn(args);\n}\n\n/**\n * Used in several -- mostly deprecated -- situations where we need to \n * apply a list of arguments or a single argument to a result selector.\n */\nexport function mapOneOrManyArgs<T, R>(fn: ((...values: T[]) => R)): OperatorFunction<T|T[], R> {\n    return map(args => callOrApply(fn, args))\n}"],"names":["Observable","Subscription","EMPTY_SUBSCRIPTION","ObjectUnsubscribedError","arrRemove","errorContext","Subject","constructor","closed","currentObservers","observers","isStopped","hasError","thrownError","lift","operator","subject","AnonymousSubject","_throwIfClosed","next","value","Array","from","observer","error","err","length","shift","complete","unsubscribe","observed","_a","_trySubscribe","subscriber","_subscribe","_checkFinalizedStatuses","_innerSubscribe","push","asObservable","observable","source","create","destination","_b","call","subscribe","argsArgArrayOrObject","identity","mapOneOrManyArgs","popResultSelector","popScheduler","createObject","createOperatorSubscriber","executeSchedule","combineLatest","args","scheduler","resultSelector","observables","keys","result","combineLatestInit","values","pipe","valueTransform","maybeSchedule","active","remainingFirstValues","i","hasFirstValue","slice","execute","subscription","EMPTY","empty","emptyScheduled","schedule","of","innerFrom","operate","catchError","selector","innerSub","syncUnsub","handledResult","undefined","mergeMap","mergeAll","concurrent","Infinity","mergeInternals","project","onBeforeNext","expand","innerSubScheduler","additionalFinalizer","buffer","index","isComplete","checkComplete","outerNext","doInnerSub","innerComplete","innerValue","bufferedValue","map","isFunction","a","b","ii","createErrorClass","EmptyError","_super","EmptyErrorImpl","name","message","ObjectUnsubscribedErrorImpl","isScheduler","last","arr","pop","popNumber","defaultValue","isArray","getPrototypeOf","prototype","objectProto","getKeys","Object","first","isPOJO","key","obj","reduce","callOrApply","fn"],"sourceRoot":"webpack:///","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13]}